; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=x86_64-unknown-linux-gnu < %s 2>&1 | FileCheck %s --check-prefix=X86ASM
; RUN: llc -mtriple=x86_64-unknown-linux-gnu -optimize-regalloc=false < %s 2>&1 | FileCheck %s --check-prefix=X86ASM_NORAOPT

declare i32 @g()

define i32 @foo() nounwind {
; X86ASM-LABEL: foo:
; X86ASM:       # %bb.0:
; X86ASM-NEXT:    pushq %rbx
; X86ASM-NEXT:    # kill: def $ebx killed $eax def $rbx
; X86ASM-NEXT:    callq g
; X86ASM-NEXT:    leal 30(%rbx,%rbx), %eax
; X86ASM-NEXT:    popq %rbx
; X86ASM-NEXT:    retq
;
; X86ASM_NORAOPT-LABEL: foo:
; X86ASM_NORAOPT:       # %bb.0:
; X86ASM_NORAOPT-NEXT:    pushq %rax
; X86ASM_NORAOPT-NEXT:    # implicit-def: $eax
; X86ASM_NORAOPT-NEXT:    movl %eax, {{[-0-9]+}}(%r{{[sb]}}p) # 4-byte Spill
; X86ASM_NORAOPT-NEXT:    callq g
; X86ASM_NORAOPT-NEXT:    # implicit-def: $rcx
; X86ASM_NORAOPT-NEXT:    movl {{[-0-9]+}}(%r{{[sb]}}p), %edx # 4-byte Reload
; X86ASM_NORAOPT-NEXT:    movl %edx, %ecx
; X86ASM_NORAOPT-NEXT:    leal 30(%rcx,%rcx), %eax
; X86ASM_NORAOPT-NEXT:    popq %rcx
; X86ASM_NORAOPT-NEXT:    retq
  %y1 = freeze i32 undef
  %k = add i32 %y1, 10
  call i32 @g()
  %k2 = add i32 %y1, 20
  %res = add i32 %k, %k2
	ret i32 %res
}
